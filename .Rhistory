knitr::opts_chunk$set(echo = TRUE)
library(httr2)
library(dplyr)
library(stringr)
library(tibble)
clean_record <- function(x) {
# 1️⃣ NULL → NA
x <- purrr::map(x, ~ if (is.null(.x)) NA else .x)
# 2️⃣ 把「會爆炸的 list 欄位」壓成字串
list_cols <- c("subjectCode", "surveyCode", "corrections")
for (col in intersect(names(x), list_cols)) {
x[[col]] <- paste(unlist(x[[col]]), collapse = ",")
if (x[[col]] == "") x[[col]] <- NA
}
# 3️⃣ 確保每個欄位都是 length-1 atomic vector
x <- purrr::map(x, ~ {
if (length(.x) == 1) .x else paste(.x, collapse = ",")
})
tibble::as_tibble(x)
}
library(httr2)
library(dplyr)
library(purrr)
library(tibble)
library(stringr)
# --- helper: GET JSON ---
wds_get <- function(url) {
resp <- request(url) |>
req_headers("Accept" = "application/json") |>
req_perform()
if (resp_status(resp) >= 400) {
stop("HTTP ", resp_status(resp))
}
resp_body_json(resp)
}
# --- 1) get all cubes list (Lite) ---
j <- wds_get("https://www150.statcan.gc.ca/t1/wds/rest/getAllCubesListLite")
# --- 2) SAFE conversion ---
cubes <- purrr::map_dfr(j, clean_record)
# --- 3) sanity check ---
glimpse(cubes)
library(httr2)
library(jsonlite)
wds_post <- function(url, body) {
resp <- request(url) |>
# 有些政府站會對沒有 UA 的 request 比較敏感
req_user_agent("DATA534-WDS-wrapper/0.1 (httr2)") |>
# Accept 放寬：有些 API 不吃 application/json 但會回 text/json
req_headers(
"Accept" = "application/json, text/json, */*",
"Content-Type" = "application/json"
) |>
req_method("POST") |>
# 用 jsonlite 自己序列化，避免 req_body_json() 產生的細節差異
req_body_raw(jsonlite::toJSON(body, auto_unbox = TRUE), type = "application/json") |>
req_perform()
if (resp_status(resp) >= 400) {
stop("HTTP ", resp_status(resp), ": ", resp_body_string(resp))
}
resp_body_json(resp)
}
library(dplyr)
library(stringr)
wait_cubes <- cubes |>
mutate(title = str_to_lower(cubeTitleEn)) |>
filter(
str_detect(title, "wait|waiting|access|treatment") &
str_detect(title, "health|hospital|surgery|medical")
) |>
select(
productId,
cansimId,
cubeTitleEn,
cubeStartDate,
cubeEndDate,
archived
) |>
arrange(desc(cubeEndDate))
wait_cubes
meta <- wds_post(
"https://www150.statcan.gc.ca/t1/wds/rest/getCubeMetadata",
list(productId = 41100081)
)
pid <- 41100081
dl <- wds_get(glue::glue(
"https://www150.statcan.gc.ca/t1/wds/rest/getFullTableDownloadCSV/{pid}/en"
))
# list(status="SUCCESS", object="https://.../n1/tbl/csv/XXXX-eng.zip")
zip_url <- dl$object
zip_url
temp_zip <- tempfile(fileext = ".zip")
download.file(
url = zip_url,
destfile = temp_zip,
mode = "wb"
)
file.exists(temp_zip)
temp_dir <- tempdir()
unzip(
zipfile = temp_zip,
exdir = temp_dir
)
list.files(temp_dir)
library(readr)
data_path <- file.path(temp_dir, "13100962.csv")
wait_data <- read_csv(data_path)
library(readr)
data_path <- file.path(temp_dir, "41100081.csv)
wait_data <- read_csv(data_path)
list.files(temp_dir)
library(readr)
data_path <- file.path(temp_dir, "41100081.csv)
wait_data <- read_csv(data_path)
library(readr)
data_path <- file.path(temp_dir, "41100081.csv")
wait_data <- read_csv(data_path)
glimpse(wait_data)
unique(wait_data$REF_DATE)
library(dplyr)
cat_cols <- wait_data %>%
select(where(is.character)) %>%
names()
cat_cols
library(purrr)
cat_summary <- map_df(
cat_cols,
~ tibble(
column = .x,
n_unique = n_distinct(wait_data[[.x]])
)
)
cat_summary %>% arrange(desc(n_unique))
sort(unique(wait_data$GEO))
unique(wait_data$Indicators)
data_path_2 <- file.path(temp_dir, "13100962_MetaData.csv")
wait_data_2 <- read_csv(data_path_2)
data_path_2 <- file.path(temp_dir, "41100081_MetaData.csv")
wait_data_2 <- read_csv(data_path_2)
glimpse(wait_data_2)
devtools::as.package(".")
devtools::as.package(".")
devtools::check()
devtools::check()
usethis::use_mit_license(Yin-Wen Tsai, Sasivimol Sirijangkapattana, Bingzheng Jin)
use_proprietary_license(copyright_holder)
usethis::use_proprietary_license(copyright_holder)
usethis::use_mit_license("Yin-Wen Tsai", "Sasivimol Sirijangkapattana", "Bingzheng Jin")
usethis::use_mit_license("Yin-Wen Tsai, Sasivimol Sirijangkapattana, Bingzheng Jin")
devtools::check()
devtools::check()
library(medianpack)
library(canHealthWaitR)
?mw_cache_dir
?mw_download_all_tables
usethis::use_github_action_check_standard()
devtools::check()
devtools::check()
devtools::document()
devtools::test()
devtools::test()
#' Plot trend over time for standardized medwait data
#'
#' @param df Standardized/filtered data (output of mw_standardize() or mw_filter())
#' @param color_by Optional column name to color lines by (e.g., "geo", "indicator")
#' @param title Optional plot title
#'
#' @return A ggplot object
#' @export
mw_plot_trend <- function(df, color_by = NULL, title = "Trend over time") {
df <- tibble::as_tibble(df)
need <- c("ref_date", "value")
if (!all(need %in% names(df))) {
rlang::abort("mw_plot_trend(): df must contain ref_date and value columns")
}
if (!is.null(color_by) && !(color_by %in% names(df))) {
rlang::abort(paste0("mw_plot_trend(): color_by column not found: ", color_by))
}
p <- ggplot2::ggplot(
df,
ggplot2::aes(
x = .data$ref_date,
y = .data$value,
color = if (is.null(color_by)) NULL else .data[[color_by]]
)
) +
ggplot2::geom_line() +
ggplot2::labs(x = "Year", y = "Value", title = title) +
ggplot2::theme_minimal()
p
}
# ===============================
# Visualization functions
# ===============================
# helper: remove Canada total
mw_filter_province <- function(df) {
dplyr::filter(df, geo != "Canada (excluding territories)")
}
#' Bar plot: provinces affected by wait time
#' @export
mw_plot_affected_province <- function(std, year = 2024) {
d <- std |>
dplyr::filter(
ref_date == year,
stat == "Number of persons",
stringr::str_detect(indicator, "affected")
) |>
mw_filter_province()
ggplot2::ggplot(
d,
ggplot2::aes(x = value, y = forcats::fct_reorder(geo, value))
) +
ggplot2::geom_col(fill = "steelblue") +
ggplot2::labs(
title = "People affected by healthcare wait times (2024)",
x = "Number of persons",
y = NULL
) +
ggplot2::theme_minimal()
}
#' Stacked (100%) bar: satisfaction vs dissatisfaction by province
#' Uses "Number of persons" to compute within-province percentages
#' @export
mw_plot_satisfaction_stack <- function(std, year = 2024) {
suppressPackageStartupMessages({
library(dplyr)
library(ggplot2)
library(forcats)
library(scales)
})
d <- std |>
dplyr::filter(
ref_date == year,
stat == "Number of persons",
indicator %in% c(
"Satisfaction with wait time - Very satisfied or satisfied",
"Satisfaction with wait time - Dissatisfied or very dissatisfied"
),
geo != "Canada (excluding territories)",
!is.na(value)
) |>
group_by(geo) |>
mutate(pct = value / sum(value)) |>
ungroup()
if (nrow(d) == 0) {
stop("No rows after filtering. Check indicator names and stat labels with table(std$stat) and unique(std$indicator).")
}
ggplot(d, aes(x = pct, y = fct_reorder(geo, pct, .fun = sum), fill = indicator)) +
geom_col(width = 0.8) +
scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
labs(
title = paste0("Satisfaction with wait times by province (", year, ")"),
x = "Share of respondents",
y = NULL,
fill = NULL
) +
theme_minimal()
}
#' Stacked (100%) bar: wait duration distribution by province
#' Uses "Number of persons" to compute within-province percentages
#' @export
mw_plot_wait_duration_stack <- function(std, year = 2024) {
suppressPackageStartupMessages({
library(dplyr)
library(ggplot2)
library(forcats)
library(scales)
})
d <- std |>
dplyr::filter(
ref_date == year,
stat == "Number of persons",
indicator %in% c(
"Wait time, less than 3 months",
"Wait time, 3 months to less than 6 months",
"Wait time, 6 months or more"
),
geo != "Canada (excluding territories)",
!is.na(value)
) |>
group_by(geo) |>
mutate(pct = value / sum(value)) |>
ungroup()
if (nrow(d) == 0) {
stop(
"No rows after filtering. Check stat and indicator labels.\n",
"Try: table(std$stat) and unique(std$indicator)"
)
}
# Optional: control the order of stack segments (left-to-right)
d$indicator <- factor(
d$indicator,
levels = c(
"Wait time, less than 3 months",
"Wait time, 3 months to less than 6 months",
"Wait time, 6 months or more"
)
)
ggplot(d, aes(x = pct, y = fct_reorder(geo, pct, .fun = sum), fill = indicator)) +
geom_col(width = 0.8) +
scale_x_continuous(labels = percent_format(accuracy = 1)) +
labs(
title = paste0("Distribution of specialist wait times by province (", year, ")"),
x = "Share of respondents",
y = NULL,
fill = "Wait duration"
) +
theme_minimal()
}
> devtools::test()
devtools::test()
rm(list = c("mw_plot_affected_province", "mw_plot_satisfaction_stack", "mw_plot_trend",
"mw_plot_wait_duration_stack"))
devtools::test()
install.packages("rlang")
install.packages("rlang")
devtools::test()
remove.packages("rlang")
install.packages("rlang", type = "binary")
install.packages("rlang", type = "binary")
install.packages("ggplot2", type = "binary")
install.packages("ggplot2", type = "binary")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
message = FALSE,
warning = FALSE
)
# Make sure all chunks run from the package root directory
knitr::opts_knit$set(root.dir = normalizePath(".."))
# Install canHealthWaitR from GitHub if not already installed
if (!requireNamespace("canHealthWaitR", quietly = TRUE)) {
devtools::install_github("Ella0921/canHealthWaitR")
}
# Load packages
library(canHealthWaitR)
library(dplyr)
install.packages("rlang")
# Install canHealthWaitR from GitHub if not already installed
if (!requireNamespace("canHealthWaitR", quietly = TRUE)) {
devtools::install_github("Ella0921/canHealthWaitR")
}
# Load packages
library(canHealthWaitR)
library(dplyr)
library(ggplot2)
ls("package:canHealthWaitR")
mw_list_tables()
# Resolve a table from the registry using its table_key
tbl <- mw_resolve_table("wait_time")
tbl
pid <- tbl$product_id[[1]]
raw <- mw_read_data(pid)
std <- mw_standardize(raw, table_id = pid)
std <- mw_standardize(raw, table_id = pid)
std <- mw_standardize(raw, table_id = pid)
std <- mw_standardize(raw, table_id = pid)
# Compare raw vs standardized structure
dplyr::glimpse(raw)
dplyr::glimpse(std)
std <- mw_standardize(raw, table_id = pid)
# Compare raw vs standardized structure
dplyr::glimpse(raw)
dplyr::glimpse(std)
std <- mw_standardize(raw, table_id = pid)
# Compare raw vs standardized structure
dplyr::glimpse(raw)
dplyr::glimpse(std)
# Compare raw vs standardized structure
dplyr::glimpse(raw)
dplyr::glimpse(std)
